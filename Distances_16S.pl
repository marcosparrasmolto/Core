#!/usr/bin/perl

use strict;
use List::Util qw( min max ); #This block of libraries are required to calculate the statics for the mean, min, sd and max
use Statistics::Basic qw(:all);
use Statistics::Descriptive;
use Math::NumberCruncher;

my $node;
my $leaves;
my @list_leaves;
my $band=1;
my @distances=undef;
my $path=$ARGV[0];
my $level_study=$ARGV[1];
my $threads=$ARGV[2];

if($level_study==97)
{
  $level_study="97_otus.fasta";
}elsif($level_study==99)
{
  $level_study="99_otus.fasta";
}


open(arch,$path."results.txt")|| die; #We open the results file from tree to get get the info of all leaves in each node.
open(output_file,">".$path."results_stats.txt"); #The output file is called this way
print output_file "Node"."\t"."Leaves"."\t"."Mean"."\t"."Desv"."\t"."Max"."\n";

while(<arch>)
{
  chomp $_;
  
  $node=(split(/\t/,$_))[0];
  $leaves=(split(/\t/,$_))[8];
  
  print $node."\t".$leaves."\n";
  
  @list_leaves=split(/;/,$leaves); #We get an array of all leaves names of each node
  
  if(scalar(@list_leaves)>1) 
  {
    foreach my $item (@list_leaves) #For each node, we grep each leaf name from the original rep_aligment sequences from greengenes
    {
      if($band==1)
      {
        system("grep '>$item' -A 1 -w ".$level_study." > ".$path."otus_test_file.fasta"); #OTUs from greengenes.
        print("grep '>$item' -A 1 -w ".$level_study." > ".$path."otus_test_file.fasta"); #OTUs from greengenes.
        $band=2;
      }else
      {
        system("grep '>$item' -A 1 -w ".$level_study." >> ".$path."otus_test_file.fasta");
      }
    }
    system("./mothur/mothur/mothur '#filter.seqs(fasta=".$path."otus_test_file.fasta,vertical=T,processors=".$threads.")'"); #Once we have subsampled all the leaves for a node, we calculate all the pairwise distances between each leaf.
    system("./mothur/mothur/mothur '#dist.seqs(fasta=".$path."otus_test_file.filter.fasta, calc=onegap,processors=".$threads.")'");
    
    open(distances,$path."otus_test_file.filter.dist"); #This is the output file containing all the pairwise combinations and their distances
    
    while(<distances>) #We get a list of all the distance values
    {
      chomp $_;
      
      my $valor=(split(/ /,$_))[2];
      
      push @distances, $valor;
    }
    
    close(distances);
    
    my $max = max @distances; #Calculate the max, mean and standard deviation here
    my $mean = Math::NumberCruncher::Mean(\@distances);
    my $sd = Math::NumberCruncher::StandardDeviation(\@distances);
    
    print output_file $node."\t".scalar(@list_leaves)."\t".$mean."\t".$sd."\t".$max."\n"; #Finally we print the info for each node
    
    $band=1;
    @distances=undef;
    system("rm -rf ".$path."otus_test_file.fasta ".$path."otus_test_file.filter ".$path."otus_test_file.filter.dist ".$path."otus_test_file.filter.fasta"); #Here we remove the temporal files generated by mothur
    
  }elsif($node ne "Core")
  {
    print output_file $node."\t".scalar(@list_leaves)."\t"."0"."\t"."0"."\t"."0"."\n"; #If a core is a leaf not a core, the result is 0 for all the variables
  }
}

close(output_file);
system("rm -rf ".$path."otus_test_file.fasta ".$path."otus_test_file.filter ".$path."otus_test_file.filter.dist ".$path."otus_test_file.filter.fasta");

